syntax = "proto3";

package proto;

option go_package = "github.com/aakselrod/minimalsigner/proto";

/*
 * Comments in this file will be directly parsed into the API
 * Documentation as descriptions of the associated method, message, or field.
 * These descriptions should go right above the definition of the object, and
 * can be in either block or // comment format.
 *
 * An RPC method can be matched to an lncli command by placing a line in the
 * beginning of the description in exactly the following format:
 * lncli: `methodname`
 *
 * Failure to specify the exact name of the command will cause documentation
 * generation to fail.
 *
 * More information on how exactly the gRPC documentation is generated from
 * this proto file can be found here:
 * https://github.com/lightninglabs/lightning-api
 */

// Lightning is the main RPC server of the daemon.
service Lightning {
  /* lncli: `signmessage`
  SignMessage signs a message with this node's private key. The returned
  signature string is `zbase32` encoded and pubkey recoverable, meaning that
  only the message digest and signature are needed for verification.
  */
  rpc SignMessage(SignMessageRequest) returns (SignMessageResponse);

  /* lncli: `getinfo`
  GetInfo returns general information concerning the lightning node including
  it's identity pubkey, alias, the chains it is connected to, and information
  concerning the number of open+pending channels.
  */
  rpc GetInfo(GetInfoRequest) returns (GetInfoResponse);

  /* lncli: `stop`
  StopDaemon will send a shutdown request to the interrupt handler, triggering
  a graceful shutdown of the daemon.
  */
  rpc StopDaemon(StopRequest) returns (StopResponse);

  /* lncli: `debuglevel`
  DebugLevel allows a caller to programmatically set the logging verbosity of
  lnd. The logging can be targeted according to a coarse daemon-wide logging
  level, or in a granular fashion to specify the logging for a target
  sub-system.
  */
  rpc DebugLevel(DebugLevelRequest) returns (DebugLevelResponse);

  /* lncli: `bakemacaroon`
  BakeMacaroon allows the creation of a new macaroon with custom read and
  write permissions. No first-party caveats are added since this can be done
  offline.
  */
  rpc BakeMacaroon(BakeMacaroonRequest) returns (BakeMacaroonResponse);

  /* lncli: `listmacaroonids`
  ListMacaroonIDs returns all root key IDs that are in use.
  */
  rpc ListMacaroonIDs(ListMacaroonIDsRequest) returns (ListMacaroonIDsResponse);

  /* lncli: `deletemacaroonid`
  DeleteMacaroonID deletes the specified macaroon ID and invalidates all
  macaroons derived from that ID.
  */
  rpc DeleteMacaroonID(DeleteMacaroonIDRequest)
      returns (DeleteMacaroonIDResponse);

  /* lncli: `listpermissions`
  ListPermissions lists all RPC method URIs and their required macaroon
  permissions to access them.
  */
  rpc ListPermissions(ListPermissionsRequest) returns (ListPermissionsResponse);

  /*
  CheckMacaroonPermissions checks whether a request follows the constraints
  imposed on the macaroon and that the macaroon is authorized to follow the
  provided permissions.
  */
  rpc CheckMacaroonPermissions(CheckMacPermRequest)
      returns (CheckMacPermResponse);
}

message SignMessageRequest {
  /*
  The message to be signed. When using REST, this field must be encoded as
  base64.
  */
  bytes msg = 1;

  /*
  Instead of the default double-SHA256 hashing of the message before signing,
  only use one round of hashing instead.
  */
  bool single_hash = 2;
}
message SignMessageResponse {
  // The signature for the given message
  string signature = 1;
}

message TimestampedError {
  // The unix timestamp in seconds when the error occurred.
  uint64 timestamp = 1;

  // The string representation of the error sent by our peer.
  string error = 2;
}

message GetInfoRequest {}
message GetInfoResponse {
  // The version of the LND software that the node is running.
  string version = 14;

  // The SHA1 commit hash that the daemon is compiled with.
  string commit_hash = 20;

  // The identity pubkey of the current node.
  string identity_pubkey = 1;

  // If applicable, the alias of the current node, e.g. "bob"
  string alias = 2;

  // The color of the current node in hex code format
  string color = 17;

  // Number of pending channels
  uint32 num_pending_channels = 3;

  // Number of active channels
  uint32 num_active_channels = 4;

  // Number of inactive channels
  uint32 num_inactive_channels = 15;

  // Number of peers
  uint32 num_peers = 5;

  // The node's current view of the height of the best block
  uint32 block_height = 6;

  // The node's current view of the hash of the best block
  string block_hash = 8;

  // Timestamp of the block best known to the wallet
  int64 best_header_timestamp = 13;

  // Whether the wallet's view is synced to the main chain
  bool synced_to_chain = 9;

  // Whether we consider ourselves synced with the public channel graph.
  bool synced_to_graph = 18;

  /*
  Whether the current node is connected to testnet. This field is
  deprecated and the network field should be used instead
  */
  bool testnet = 10 [ deprecated = true ];

  reserved 11;

  // A list of active chains the node is connected to
  repeated Chain chains = 16;

  // The URIs of the current node.
  repeated string uris = 12;

  /*
  Features that our node has advertised in our init message, node
  announcements and invoices.
  */
  map<uint32, Feature> features = 19;

  /*
  Indicates whether the HTLC interceptor API is in always-on mode.
  */
  bool require_htlc_interceptor = 21;
}

message Chain {
  // The blockchain the node is on (eg bitcoin, litecoin)
  string chain = 1;

  // The network the node is on (eg regtest, testnet, mainnet)
  string network = 2;
}

message KeyLocator {
  // The family of key being identified.
  int32 key_family = 1;

  // The precise index of the key being identified.
  int32 key_index = 2;
}

message KeyDescriptor {
  /*
  The raw bytes of the key being identified.
  */
  bytes raw_key_bytes = 1;

  /*
  The key locator that identifies which key to use for signing.
  */
  KeyLocator key_loc = 2;
}

message StopRequest {}
message StopResponse {}

message DebugLevelRequest {
  bool show = 1;
  string level_spec = 2;
}
message DebugLevelResponse { string sub_systems = 1; }

message Feature {
  string name = 2;
  bool is_required = 3;
  bool is_known = 4;
}

message MacaroonPermission {
  // The entity a permission grants access to.
  string entity = 1;

  // The action that is granted.
  string action = 2;
}
message BakeMacaroonRequest {
  // The list of permissions the new macaroon should grant.
  repeated MacaroonPermission permissions = 1;

  // The root key ID used to create the macaroon, must be a positive integer.
  uint64 root_key_id = 2;

  /*
  Informs the RPC on whether to allow external permissions that LND is not
  aware of.
  */
  bool allow_external_permissions = 3;
}
message BakeMacaroonResponse {
  // The hex encoded macaroon, serialized in binary format.
  string macaroon = 1;
}

message ListMacaroonIDsRequest {}
message ListMacaroonIDsResponse {
  // The list of root key IDs that are in use.
  repeated uint64 root_key_ids = 1;
}

message DeleteMacaroonIDRequest {
  // The root key ID to be removed.
  uint64 root_key_id = 1;
}
message DeleteMacaroonIDResponse {
  // A boolean indicates that the deletion is successful.
  bool deleted = 1;
}

message MacaroonPermissionList {
  // A list of macaroon permissions.
  repeated MacaroonPermission permissions = 1;
}

message ListPermissionsRequest {}
message ListPermissionsResponse {
  /*
  A map between all RPC method URIs and their required macaroon permissions to
  access them.
  */
  map<string, MacaroonPermissionList> method_permissions = 1;
}

message MacaroonId {
  bytes nonce = 1;
  bytes storageId = 2;
  repeated Op ops = 3;
}

message Op {
  string entity = 1;
  repeated string actions = 2;
}

message CheckMacPermRequest {
  bytes macaroon = 1;
  repeated MacaroonPermission permissions = 2;
  string fullMethod = 3;
}

message CheckMacPermResponse { bool valid = 1; }
